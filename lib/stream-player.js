// Generated by CoffeeScript 1.9.3
var Speaker, StreamPlayer, audioOptions, events, lame, loadNextSong, request, self,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Speaker = require('speaker');

lame = require('lame');

request = require('request');

events = require('events');

audioOptions = {
  channels: 2,
  bitDepth: 16,
  sampleRate: 44100,
  mode: lame.STEREO
};

self = null;

StreamPlayer = (function(superClass) {
  extend(StreamPlayer, superClass);

  function StreamPlayer() {
    events.EventEmitter.call(this);
    self = this;
    this.queue = [];
    this.trackInfo = [];
    this.currentSong = null;
    this.playing = false;
    this.startTime = 0;
  }

  StreamPlayer.prototype.play = function() {
    if (this.queue.length > 0 && !this.playing) {
      this.getStream(this.queue[0], this.playStream);
      this.playing = true;
      this.queue.shift();
      return this.currentSong = self.trackInfo.shift();
    } else if (this.playing) {
      return new Error('A song is already playing.');
    } else {
      return new Error('The queue is empty.');
    }
  };

  StreamPlayer.prototype.remove = function(id) {
    var index;
    index = trackInfo.map(function(info) {
      return info.id;
    }).indexOf(id);
    trackInfo.splice(index, 1);
    return queue.splice(index, 1);
  };

  StreamPlayer.prototype.add = function(url, track) {
    this.queue.push(url);
    this.trackInfo.push(track);
    return this.emit('song added');
  };

  StreamPlayer.prototype.nowPlaying = function() {
    if (this.playing) {
      return {
        track: this.currentSong,
        timestamp: this.startTime
      };
    } else {
      return new Error('No song is currently playing.');
    }
  };

  StreamPlayer.prototype.isPlaying = function() {
    return this.playing;
  };

  StreamPlayer.prototype.getQueue = function() {
    return this.trackInfo;
  };

  StreamPlayer.prototype.getStream = function(url, callback) {
    return request.get(url).on('response', function(res) {
      if (res.headers['content-type'] === 'audio/mpeg') {
        return callback(res);
      } else {
        self.emit('invalid url');
        return loadNextSong();
      }
    });
  };

  StreamPlayer.prototype.playStream = function(stream) {
    var decoder, speaker;
    decoder = new lame.Decoder();
    speaker = new Speaker(audioOptions);
    return stream.pipe(decoder).once('format', function() {
      decoder.pipe(speaker);
      self.startTime = Date.now();
      self.emit('play start');
      return speaker.once('close', function() {
        return loadNextSong();
      });
    });
  };

  return StreamPlayer;

})(events.EventEmitter);

loadNextSong = function() {
  self.currentSong = null;
  self.playing = false;
  self.emit('play end');
  return self.play();
};

module.exports = StreamPlayer;
